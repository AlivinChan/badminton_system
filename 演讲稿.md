# 校园羽毛球馆场地预约管理系统 - 项目讲解演讲稿

## 第一部分：项目概述（2分钟）

### 1.1 项目介绍
大家好，今天我将为大家介绍一个基于Java开发的校园羽毛球馆场地预约管理系统。这是一个桌面应用程序，使用Java Swing构建图形界面，采用JSON文件进行数据持久化，完全使用Java标准库实现，无需任何外部依赖。

### 1.2 项目结构概览
项目采用经典的分层架构设计，主要分为四个层次：
- **模型层（Model）**: 定义数据实体
- **持久化层（Persistence）**: 处理数据存储
- **服务层（Service）**: 封装业务逻辑
- **UI层（UI）**: 用户界面

现在让我带大家深入了解每个层次的具体实现。

---

## 第二部分：项目结构详解（5分钟）

### 2.1 项目目录结构
首先，我们来看项目的目录结构。项目源代码位于 `src/main/java/com/badminton/` 目录下。

**核心包结构**：
```
com.badminton
├── model/              # 数据模型层
├── persistence/        # 数据持久化层
├── service/            # 业务服务层
├── util/               # 工具类
└── ui/                 # 用户界面层
    ├── console/        # 控制台界面
    └── swing/          # Swing图形界面
```

### 2.2 入口程序
程序的入口点是 `src/main/java/com/badminton/Main.java`，这是一个简单的启动类。

**关键代码位置**：`src/main/java/com/badminton/Main.java` 第12-29行

```12:29:src/main/java/com/badminton/Main.java
public static void main(String[] args) {
    // 如果命令行参数包含 "console"，则启动控制台界面
    if (args.length > 0 && args[0].equals("console")) {
        ConsoleUI ui = new ConsoleUI();
        ui.start();
    } else {
        // 默认启动图形界面
        SwingUtilities.invokeLater(() -> {
            try {
                // 设置系统外观
                UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
            } catch (Exception e) {
                e.printStackTrace();
            }
            new MainFrame().setVisible(true);
        });
    }
}
```

这里可以看到，程序支持两种运行模式：控制台模式和图形界面模式。默认启动Swing图形界面。

---

## 第三部分：数据模型层详解（5分钟）

### 3.1 核心实体类
数据模型层定义了系统的核心实体，包括学生、管理员、场地、预约等。

#### 3.1.1 TimeSlot（时间段模型）
**文件位置**：`src/main/java/com/badminton/model/TimeSlot.java`

这是系统中最核心的模型之一，用于表示预约的时间段。它包含日期、开始时间和结束时间。

**关键方法 - 冲突检测算法**：第57-63行

```57:63:src/main/java/com/badminton/model/TimeSlot.java
public boolean overlaps(TimeSlot other) {
    if (other == null || !this.date.equals(other.date)) {
        return false; // 不同日期不重叠
    }
    // 重叠条件：!(this.end <= other.start || other.end <= this.start)
    return !(this.end.compareTo(other.start) <= 0 || other.end.compareTo(this.start) <= 0);
}
```

这个算法的核心思想是：两个时间段不重叠的条件是"一个完全在另一个之前或之后"，取反后就是重叠条件。这是经典的区间重叠检测算法。

#### 3.1.2 Booking（预约模型）
**文件位置**：`src/main/java/com/badminton/model/Booking.java`

预约模型包含了预约的所有信息，包括预约ID、学生、场地、时间段、状态、费用、评分等。

**关键属性**：第14-21行

```14:21:src/main/java/com/badminton/model/Booking.java
private String bookingId;
private Student student;
private String courtId;
private TimeSlot slot;
private BookingState state;
private double fee; // 预约费用（在创建或确认时计算）
private int rating; // 学生对场地的评分（0-5），0表示未评分
private transient LocalDateTime createdAt; // 使用 transient 标记，手动序列化
```

注意 `createdAt` 使用了 `transient` 关键字，因为 `LocalDateTime` 不能直接序列化，需要自定义序列化方法。

---

## 第四部分：持久化层详解（8分钟）

### 4.1 JsonDB - 核心持久化类
**文件位置**：`src/main/java/com/badminton/persistence/JsonDB.java`

这是整个系统最复杂也最有趣的部分。我们实现了一个不依赖任何外部JSON库的JSON解析和序列化系统。

#### 4.1.1 数据存储结构
数据存储在 `data/` 目录下，每个实体类型对应一个JSON文件：
- `students.json` - 学生数据
- `admins.json` - 管理员数据
- `courts.json` - 场地数据
- `bookings.json` - 预约数据

**文件路径定义**：第18-22行

```18:22:src/main/java/com/badminton/persistence/JsonDB.java
private static final String DATA_DIR = "data";
private static final String STUDENTS_FILE = DATA_DIR + File.separator + "students.json";
private static final String ADMINS_FILE = DATA_DIR + File.separator + "admins.json";
private static final String COURTS_FILE = DATA_DIR + File.separator + "courts.json";
private static final String BOOKINGS_FILE = DATA_DIR + File.separator + "bookings.json";
```

#### 4.1.2 大括号匹配算法
这是JSON解析的核心算法。我们需要找到嵌套对象的结束位置。

**算法实现**：第474-484行

```474:484:src/main/java/com/badminton/persistence/JsonDB.java
private int findMatchingBrace(String str, int start) {
    int count = 0;
    for (int i = start; i < str.length(); i++) {
        if (str.charAt(i) == '{') count++;
        if (str.charAt(i) == '}') {
            count--;
            if (count == 0) return i;
        }
    }
    return -1;
}
```

这个算法使用计数器来跟踪嵌套层级。每当遇到 `{` 时计数器加1，遇到 `}` 时减1。当计数器归零时，就找到了匹配的结束位置。

#### 4.1.3 JSON解析流程
以读取学生数据为例，解析流程如下：

**解析方法**：第301-340行

```301:340:src/main/java/com/badminton/persistence/JsonDB.java
private List<Student> readStudentsFromFile(String filePath) {
    List<Student> result = new ArrayList<>();
    File file = new File(filePath);
    if (!file.exists()) {
        return result;
    }
    
    try (BufferedReader reader = new BufferedReader(new InputStreamReader(
            new FileInputStream(file), StandardCharsets.UTF_8))) {
        String content = readAll(reader);
        if (content == null || content.trim().isEmpty()) {
            return result;
        }
        
        // 简单的JSON解析 - 查找所有对象
        int start = content.indexOf('[');
        if (start == -1) return result;
        
        int pos = start + 1;
        while (pos < content.length()) {
            int objStart = content.indexOf('{', pos);
            if (objStart == -1) break;
            
            int objEnd = findMatchingBrace(content, objStart);
            if (objEnd == -1) break;
            
            String objJson = content.substring(objStart, objEnd + 1);
            Student student = parseStudent(objJson);
            if (student != null) {
                result.add(student);
            }
            
            pos = objEnd + 1;
        }
    } catch (IOException e) {
        System.err.println("读取学生数据失败: " + e.getMessage());
    }
    
    return result;
}
```

解析步骤：
1. 读取整个文件内容
2. 找到数组开始标记 `[`
3. 循环查找每个对象开始标记 `{`
4. 使用大括号匹配算法找到对象结束位置
5. 提取对象JSON字符串并解析

#### 4.1.4 JSON序列化
序列化相对简单，我们手动构建JSON字符串。

**序列化方法**：第186-208行

```186:208:src/main/java/com/badminton/persistence/JsonDB.java
private <T> void writeListToFile(String filePath, List<T> data, String type) throws IOException {
    File file = new File(filePath);
    File parentDir = file.getParentFile();
    if (parentDir != null && !parentDir.exists()) {
        parentDir.mkdirs();
    }
    
    try (PrintWriter writer = new PrintWriter(new OutputStreamWriter(
            new FileOutputStream(file), StandardCharsets.UTF_8))) {
        writer.println("[");
        for (int i = 0; i < data.size(); i++) {
            T item = data.get(i);
            String json = toJson(item, type);
            writer.print("  " + json);
            if (i < data.size() - 1) {
                writer.println(",");
            } else {
                writer.println();
            }
        }
        writer.println("]");
    }
}
```

---

## 第五部分：服务层详解（8分钟）

### 5.1 BookingService - 预约服务
**文件位置**：`src/main/java/com/badminton/service/BookingService.java`

这是业务逻辑的核心服务类，处理所有预约相关的业务。

#### 5.1.1 冲突检测方法
**关键方法**：第112-128行

```112:128:src/main/java/com/badminton/service/BookingService.java
public boolean isConflict(String courtId, TimeSlot slot) {
    Booking[] bookings = db.getBookings();

    for (int i = 0; i < db.getBookingCount(); i++) {
        Booking booking = bookings[i];
        if (booking == null) continue;

        if (!booking.getCourtId().equals(courtId)) continue;
        if (booking.getState() == BookingState.CANCELLED) continue;

        if (booking.getSlot().overlaps(slot)) {
            return true;
        }
    }

    return false;
}
```

这个方法的核心逻辑：
1. 遍历所有预约
2. 过滤出同一场地的预约
3. 排除已取消的预约
4. 使用 `TimeSlot.overlaps()` 方法检测时间段重叠

#### 5.1.2 创建预约方法
**关键方法**：第25-63行

```25:63:src/main/java/com/badminton/service/BookingService.java
public Booking createBooking(String studentId, String courtId, TimeSlot slot) throws BusinessException {
    Student student = db.findStudentById(studentId);
    if (student == null) {
        throw new BusinessException("学生不存在");
    }

    Court court = db.findCourtById(courtId);
    if (court == null) {
        throw new BusinessException("场地不存在");
    }

    if (court.getStatus() == CourtStatus.MAINTENANCE) {
        throw new BusinessException("该场地正在维护中，不可预约");
    }

    if (isConflict(courtId, slot)) {
        throw new BusinessException("该时段场地已被预约");
    }

    // 计算费用
    double fee = feePolicy.computeFee(court.getType(), slot);

    // 创建预约
    Booking booking = new Booking(
            db.generateBookingId(),
            student,
            courtId,
            slot,
            BookingState.PENDING,
            fee,
            0,
            LocalDateTime.now()
    );

    db.addBooking(booking);
    db.saveToFile();

    return booking;
}
```

创建预约的完整流程：
1. 验证学生是否存在
2. 验证场地是否存在
3. 检查场地是否维护中
4. 检测时间段冲突
5. 计算费用（使用策略模式）
6. 创建预约对象
7. 保存到数据库

---

## 第六部分：UI层详解（10分钟）

### 6.1 MainFrame - 主窗口
**文件位置**：`src/main/java/com/badminton/ui/swing/MainFrame.java`

主窗口负责管理整个应用程序的生命周期和面板切换。

#### 6.1.1 服务初始化
**关键代码**：第35-46行

```35:46:src/main/java/com/badminton/ui/swing/MainFrame.java
private void initializeServices() {
    db = JsonDB.loadFromFile();
    DefaultFeePolicy feePolicy = new DefaultFeePolicy();
    userService = new UserService(db);
    bookingService = new BookingService(db, feePolicy);
    courtService = new CourtService(db, bookingService);
    adminService = new AdminService(db);
    statisticsService = new StatisticsService(db);

    // 初始化默认数据
    initializeDefaultData();
}
```

这里可以看到依赖注入的模式：各个服务类通过构造函数接收依赖，实现了松耦合。

#### 6.1.2 UI初始化
**关键代码**：第85-111行

```85:111:src/main/java/com/badminton/ui/swing/MainFrame.java
private void initializeUI() {
    setTitle("校园羽毛球馆场地预约管理系统");
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    setSize(1200, 800);
    setLocationRelativeTo(null);
    setMinimumSize(new Dimension(1000, 600));

    // 创建菜单栏
    createMenuBar();

    // 主面板使用CardLayout
    cardLayout = new CardLayout();
    mainPanel = new JPanel(cardLayout);
    mainPanel.setBackground(new Color(248, 249, 252));

    // 创建各个面板
    loginPanel = new LoginPanel(this, userService, adminService);
    studentDashboardPanel = new StudentDashboardPanel(this, userService, bookingService, courtService);
    adminDashboardPanel = new AdminDashboardPanel(this, adminService, bookingService, 
            courtService, statisticsService);

    mainPanel.add(loginPanel, "LOGIN");
    mainPanel.add(studentDashboardPanel, "STUDENT");
    mainPanel.add(adminDashboardPanel, "ADMIN");

    add(mainPanel);
}
```

使用 `CardLayout` 来管理多个面板，实现面板之间的切换。

### 6.2 LoginPanel - 登录面板
**文件位置**：`src/main/java/com/badminton/ui/swing/LoginPanel.java`

登录面板实现了学生注册、学生登录和管理员登录功能。

#### 6.2.1 自定义按钮样式
**关键代码**：第69-120行

```69:120:src/main/java/com/badminton/ui/swing/LoginPanel.java
private JButton createStyledButton(String text, int width, int height) {
    JButton button = new JButton(text) {
        @Override
        protected void paintComponent(Graphics g) {
            if (getWidth() <= 0 || getHeight() <= 0) return;
            
            Graphics2D g2 = (Graphics2D) g.create();
            try {
                g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                
                // 绘制圆角蓝色背景
                Color bgColor = isEnabled() ? 
                    (getModel().isRollover() ? new Color(80, 140, 190) : new Color(70, 130, 180)) :
                    new Color(180, 180, 180);
                g2.setColor(bgColor);
                int arc = 8; // 圆角半径
                g2.fillRoundRect(0, 0, getWidth(), getHeight(), arc, arc);
                
                // 绘制白色文字
                if (getText() != null && !getText().isEmpty()) {
                    g2.setColor(Color.WHITE);
                    g2.setFont(getFont());
                    FontMetrics fm = g2.getFontMetrics();
                    int x = (getWidth() - fm.stringWidth(getText())) / 2;
                    int y = (getHeight() + fm.getAscent() - fm.getDescent()) / 2;
                    g2.drawString(getText(), x, y);
                }
            } finally {
                g2.dispose();
            }
        }
    };
```

这里使用了自定义绘制来实现圆角按钮。关键点：
- 重写 `paintComponent` 方法
- 使用 `Graphics2D` 进行高级绘制
- 启用抗锯齿以获得平滑效果
- 手动计算文字居中位置

### 6.3 StudentDashboardPanel - 学生功能面板
**文件位置**：`src/main/java/com/badminton/ui/swing/StudentDashboardPanel.java`

这是最复杂的面板，实现了学生预约的所有功能。

#### 6.3.1 时间输入规范化
**关键方法**：第43-46行

```43:46:src/main/java/com/badminton/ui/swing/StudentDashboardPanel.java
private String normalizeTimeString(String timeStr) {
    if (timeStr == null) return null;
    return timeStr.replace("：", ":"); // 将中文冒号（：）替换为英文冒号（:）
}
```

这个小方法实现了中英文冒号的兼容，提升了用户体验。

#### 6.3.2 实时冲突检测与高亮显示
这是系统最核心的UI功能之一。当用户输入日期和时间时，系统会实时检测哪些场地有冲突，并用红色高亮显示。

**关键方法**：第430-496行

```430:496:src/main/java/com/badminton/ui/swing/StudentDashboardPanel.java
private void showAllCourts() {
    availableCourtsModel.setRowCount(0);
    Court[] courts = courtService.getAllCourts();
    
    // 尝试获取用户输入的时间段
    TimeSlot tempTimeSlot = null;
    try {
        String dateStr = dateField.getText().trim();
        String startTimeStr = normalizeTimeString(startTimeField.getText().trim());
        String endTimeStr = normalizeTimeString(endTimeField.getText().trim());
        
        if (!dateStr.isEmpty() && !startTimeStr.isEmpty() && !endTimeStr.isEmpty()) {
            LocalDate date = LocalDate.parse(dateStr, dateFormatter);
            LocalTime startTime = LocalTime.parse(startTimeStr, timeFormatter);
            LocalTime endTime = LocalTime.parse(endTimeStr, timeFormatter);
            tempTimeSlot = new TimeSlot(date, startTime, endTime);
        }
    } catch (Exception e) {
        // 如果时间格式不正确，忽略错误，不进行冲突检查
        tempTimeSlot = null;
    }
    final TimeSlot userTimeSlot = tempTimeSlot;
    
    // 设置自定义渲染器，用于标红冲突的场地
    availableCourtsTable.setDefaultRenderer(Object.class, new javax.swing.table.DefaultTableCellRenderer() {
        @Override
        public java.awt.Component getTableCellRendererComponent(JTable table, Object value,
                boolean isSelected, boolean hasFocus, int row, int column) {
            super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
            
            // 获取该行的场地编号
            String courtId = (String) table.getValueAt(row, 0);
            
            // 检查是否有时间段冲突
            boolean hasConflict = false;
            if (userTimeSlot != null && courtId != null) {
                hasConflict = bookingService.isConflict(courtId, userTimeSlot);
            }
            
            // 如果有冲突，标红显示
            if (hasConflict) {
                setBackground(new Color(255, 200, 200)); // 淡红色背景
                setForeground(new Color(180, 0, 0)); // 深红色文字
            } else {
                setBackground(new Color(173, 216, 230)); // 淡蓝色背景
                setForeground(Color.WHITE); // 白色文字
            }
            setOpaque(true);
            return this;
        }
    });
    
    for (Court court : courts) {
        // 检查是否有时间段冲突
        boolean hasConflict = false;
        if (userTimeSlot != null) {
            hasConflict = bookingService.isConflict(court.getCourtId(), userTimeSlot);
        }
        
        // 如果有冲突，状态显示为 UNAVAILABLE，否则显示实际状态
        Object statusDisplay = hasConflict ? "UNAVAILABLE" : court.getStatus();
        
        availableCourtsModel.addRow(new Object[]{
            court.getCourtId(),
            court.getType(),
            statusDisplay
        });
    }
}
```

这个方法的实现要点：
1. 首先尝试解析用户输入的时间段
2. 为表格设置自定义渲染器
3. 在渲染每个单元格时，检查该场地是否有冲突
4. 如果有冲突，使用红色背景和文字；否则使用蓝色背景和白色文字
5. 在状态列中，冲突的场地显示为"UNAVAILABLE"

#### 6.3.3 实时监听输入变化
为了实现实时冲突检测，我们需要监听输入框的变化。

**关键代码**：第200-220行（在 `createQueryPanel()` 方法中）

```200:220:src/main/java/com/badminton/ui/swing/StudentDashboardPanel.java
// 添加文档监听器，实现实时冲突检测
dateField.getDocument().addDocumentListener(new javax.swing.event.DocumentListener() {
    @Override
    public void insertUpdate(javax.swing.event.DocumentEvent e) {
        showAllCourts();
    }
    @Override
    public void removeUpdate(javax.swing.event.DocumentEvent e) {
        showAllCourts();
    }
    @Override
    public void changedUpdate(javax.swing.event.DocumentEvent e) {
        showAllCourts();
    }
});
```

每当用户输入或删除字符时，都会触发 `showAllCourts()` 方法，实时更新表格显示。

#### 6.3.4 预约创建与验证
**关键方法**：第492-570行

```492:570:src/main/java/com/badminton/ui/swing/StudentDashboardPanel.java
private void createBooking() {
    if (currentStudent == null) {
        JOptionPane.showMessageDialog(this, "请先登录", "提示", JOptionPane.WARNING_MESSAGE);
        return;
    }

    try {
        String courtId = courtIdField.getText().trim();
        if (courtId.isEmpty()) {
            JOptionPane.showMessageDialog(this, "请输入场地编号", "提示", JOptionPane.WARNING_MESSAGE);
            return;
        }

        LocalDate date = LocalDate.parse(dateField.getText(), dateFormatter);
        
        // 验证时间格式和整点要求
        String startTimeStr = normalizeTimeString(startTimeField.getText().trim());
        String endTimeStr = normalizeTimeString(endTimeField.getText().trim());
        
        // 检查时间格式是否为 HH:00 或 HH：00（支持中英文冒号）
        if (!startTimeStr.matches("\\d{1,2}:00")) {
            JOptionPane.showMessageDialog(this, 
                "开始时间必须为整点格式（HH:00 或 HH：00），例如：09:00, 10：00, 15:00", 
                "格式错误", JOptionPane.WARNING_MESSAGE);
            return;
        }
        
        if (!endTimeStr.matches("\\d{1,2}:00")) {
            JOptionPane.showMessageDialog(this, 
                "结束时间必须为整点格式（HH:00 或 HH：00），例如：09:00, 10：00, 15:00", 
                "格式错误", JOptionPane.WARNING_MESSAGE);
            return;
        }
        
        LocalTime start = LocalTime.parse(startTimeStr, timeFormatter);
        LocalTime end = LocalTime.parse(endTimeStr, timeFormatter);
        
        // 验证分钟是否为00
        if (start.getMinute() != 0) {
            JOptionPane.showMessageDialog(this, 
                "开始时间必须为整点（分钟必须为00），例如：09:00, 10:00, 15:00",
                "格式错误", JOptionPane.WARNING_MESSAGE);
            return;
        }
        
        if (end.getMinute() != 0) {
            JOptionPane.showMessageDialog(this, 
                "结束时间必须为整点（分钟必须为00），例如：09:00, 10:00, 15:00",
                "格式错误", JOptionPane.WARNING_MESSAGE);
            return;
        }
        
        // 验证结束时间晚于开始时间
        if (!end.isAfter(start)) {
            JOptionPane.showMessageDialog(this, 
                "结束时间必须晚于开始时间", "格式错误", JOptionPane.WARNING_MESSAGE);
            return;
        }

        TimeSlot slot = new TimeSlot(date, start, end);
        Booking booking = bookingService.createBooking(
                currentStudent.getStudentId(), courtId, slot);

        JOptionPane.showMessageDialog(this, 
            "预约成功！预约ID：" + booking.getBookingId() + 
            "\n费用：" + String.format("%.2f", booking.getFee()) + "元",
            "成功", JOptionPane.INFORMATION_MESSAGE);

        // 刷新表格
        showAllCourts();
        refreshMyBookings();
        
        // 清空输入框
        courtIdField.setText("");
        dateField.setText("");
        startTimeField.setText("");
        endTimeField.setText("");
    } catch (BusinessException e) {
        JOptionPane.showMessageDialog(this, e.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
    } catch (Exception e) {
        JOptionPane.showMessageDialog(this, "输入格式错误：" + e.getMessage(), 
            "错误", JOptionPane.ERROR_MESSAGE);
    }
}
```

这个方法的验证逻辑非常完善：
1. 检查用户是否登录
2. 验证场地编号不为空
3. 验证时间格式为整点（HH:00）
4. 验证分钟必须为00
5. 验证结束时间晚于开始时间
6. 调用服务层创建预约
7. 显示成功信息并刷新界面

---

## 第七部分：核心算法总结（3分钟）

### 7.1 时间段冲突检测算法
我们已经在前面的 `TimeSlot.overlaps()` 方法中看到了这个算法。它的时间复杂度是 O(1)，非常高效。

### 7.2 JSON解析算法
大括号匹配算法的时间复杂度是 O(n)，其中 n 是字符串长度。对于嵌套层级不深的JSON文件，这个算法非常高效。

### 7.3 实时冲突检测
在UI层，我们实现了实时冲突检测。每当用户输入变化时，都会：
1. 解析用户输入的时间段
2. 遍历所有场地
3. 对每个场地调用 `isConflict()` 方法
4. 更新表格显示

这个功能的时间复杂度是 O(m×k)，其中 m 是场地数量，k 是已有预约数量。对于实际应用场景，这个性能是可以接受的。

---

## 第八部分：项目亮点总结（2分钟）

### 8.1 技术亮点
1. **无外部依赖**: 完全使用Java标准库实现JSON解析，无需Gson等第三方库
2. **实时反馈**: 输入时实时检测冲突并高亮显示，用户体验优秀
3. **用户体验优化**: 支持中英文冒号，友好的错误提示
4. **代码组织**: 清晰的分层架构，职责分离明确

### 8.2 设计模式应用
1. **服务层模式**: Service类封装业务逻辑，实现业务与UI分离
2. **策略模式**: FeePolicy接口实现费用计算策略，易于扩展
3. **MVC模式**: Model-View-Controller分离，代码结构清晰

### 8.3 可维护性
- 代码结构清晰，包组织合理
- 方法职责单一，易于测试
- 异常处理完善
- 注释充分，易于理解

---

## 第九部分：演示建议（2分钟）

在录制视频时，建议按以下顺序演示：

1. **启动程序**：展示主窗口和登录界面
2. **学生注册登录**：演示注册和登录流程
3. **场地查询**：输入日期和时间，展示实时冲突检测和高亮显示
4. **创建预约**：演示预约流程，包括格式验证
5. **查看我的预约**：展示预约列表和取消功能
6. **管理员功能**：演示管理员登录、预约管理、场地管理
7. **数据持久化**：关闭程序后重新打开，展示数据已保存

在演示过程中，可以：
- 打开代码文件，展示关键代码位置
- 解释算法原理
- 展示数据文件结构

---

## 结语

这个项目展示了如何使用Java标准库构建一个完整的桌面应用程序，包括数据持久化、业务逻辑处理和用户界面设计。虽然功能相对简单，但代码结构清晰，易于理解和扩展。

感谢大家的观看！

---

**演讲稿版本**: 1.0  
**录制建议时长**: 35-40分钟  
**适用场景**: 项目演示、代码讲解、技术分享

